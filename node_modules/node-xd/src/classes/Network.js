class Network {
    async updateNetworkConfig(config) {
        return new Promise(async (resolve, reject) => {
            try {
                var existing = await this.client.get('/1.0/networks/' + this.bridge)
            } catch (error) {
                reject(error)
            }
            if (existing.metadata == null) existing.metadata = { config: {} };
            var newConfig = { ...existing.metadata.config, ...config }
            try {
                var res = await this.client.patch('/1.0/networks/' + this.bridge, {
                    config: newConfig
                })
            } catch (error) {
                reject(error)
            }
            resolve(res)
        })
    }

    /**
     * Creates Port forward on bridge
     * @param {string} listen_address
     * @param {string} description
     * @param {{}[]} ports
     * @returns {Promise<{}>}
     */
    async createNetworkForward(listen_address, description, ports) {
        return new Promise(async (resolve, reject) => {
            try {
                if (!listen_address) throw new Error('Listen Address not specified');
                var data = {
                    "description": description ? description : "A Network Forward",
                    "listen_address": listen_address,
                    "ports": ports
                }
                console.log(`/1.0/networks/${this.bridge}/forwards`)
                var res = await this.client.post('/1.0/networks/' + this.bridge + '/forwards', data)
                resolve(res);
            } catch (error) {
                reject(error)
            }
        })

    }
    /**
     * Appends a port forward to exsisting forward
     * @param {string} listen_address
     * @param {{}[]} ports
     * @returns {Promise<{}>}
     */
    async appendNetworkForward(listen_address, ports) {
        return new Promise(async (resolve, reject) => {
            try {
                if (!ports) throw new Error('Ports not specified');
                let all_ports = []
                all_ports.concat(ports)
                var existing_ports = await this.client.get("/1.0/networks/" + this.bridge + "/forwards/" + listen_address)
                all_ports = ports.concat(existing_ports.metadata.ports)
                var res = await this.client.patch('/1.0/networks/' + this.bridge + '/forwards/' + listen_address, {
                    "ports": all_ports
                })
                resolve(res)
            } catch (error) {
                reject(error)
            }
        })

    }
    async fetchNetworkForward(listen_address) {
        return new Promise(async (resolve, reject) => {
            try {
                var data = await this.client.get("/1.0/networks/" + this.bridge + "/forwards/" + listen_address)
                resolve(data.metadata)
            } catch (error) {
                reject(error)
            }
        })

    }
    async fetchNetworkForwards() {
        return new Promise(async (resolve, reject) => {
            try {
                var data = await this.client.get("/1.0/networks/" + this.bridge + "/forwards")
                var res = []
                if (data.metadata != null) for (var forward of data.metadata) {
                    res.push((await this.client.get(forward)).metadata)
                }
                resolve(res)
            } catch (error) {
                reject(error)
            }
        })

    }
    constructor(bridge, rootClient) {
        /**
         * @private
         * @type {import('../lib/RequestClient')}
         */
        this.client = rootClient;
        /**
         * @private
         * @type {string}
         */
        this.bridge = bridge
    }
}
module.exports = Network;